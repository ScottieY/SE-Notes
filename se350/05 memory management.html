<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/SE-Notes/style.css" type="text/css" />
</head>
<body>
<h1 id="memory-management">Memory Management</h1><p>Responsible for dividing memory to accomodate multiple processes</p><h2 id="relocation">Relocation</h2><ul><li>Programmer doesn't know where the pmemory will be placed when executed</li><li>While program is executing, it may be swapped to disk and returned to memory in a new location</li><li>Memory references must be translated in the code to actual physical memory address</li></ul><h2 id="requirement">Requirement</h2><ul><li>PCB</li><li>Program</li><li>Data, referenced by program</li><li>Stack</li></ul><h3 id="protection">Protection</h3><ul><li>Shouldnt be able to reference memory locations from another process without permission</li><li>Impossible to check the absolute address at compile time</li></ul><h3 id="logical-organization">Logical organization</h3><ul><li>programs written in modules</li><li>modules can be written and compiled independently</li><li>different degrees of protection given to modules (read only, execute only)</li><li>share modules among processes</li></ul><h2 id="strategies">Strategies</h2><ul><li>Equal sized partitions</li><li>Fixed partitioning</li><li>Dynamic partitioning: assign resources dynamically when asked<ul><li>Problem: you get gaps and holes in memory when processes terminate</li><li>Algorithm: best fit vs next fit</li><li>buddy system: creates smaller and smaller blocks to fit things in</li></ul></li></ul><h2 id="relocation-1">Relocation</h2><ul><li>A process may switch memory locations</li></ul><h3 id="addresses">Addresses</h3><ul><li>Logical: reference to a memory location independent of current assignment of data. Translation must be made to physical</li><li>Relative: Address expressed as a location relative to some point<ul><li>Uses base register, bounds register, adder, comparator</li></ul></li><li>Physical: absolute address</li></ul><h2 id="external-fragmentation">External fragmentation</h2><h3 id="paging">Paging</h3><ul><li>partition memory into small equal fixed sized chunks. Divide each process into the same sized chunks</li><li>Chunks of a process are pages, chunks of memory are frames</li><li>OS maintains a page table for each process<ul><li>contains frame location for each page in process</li><li>memory address is a <strong>page number and offset</strong></li></ul></li><li>Logical to physical is still done by hardware<ul><li>logical address: page, offset</li><li>physical address: frame, offset</li><li>The memory address is now a 16 bit logical address: 6 bit page, 10 bit offset<ul><li>The page part goes through the page table lookup, and then the offset gets added</li></ul></li></ul></li><li>Program divided into <strong>segments</strong><ul><li>all segments do not have to be the same length</li><li>max segment length exists</li><li>since segments are not wqual, segmentation is similar to dynamic partitioning<ul><li>programs can have more segments but only one partition<ul><li>e.g. 4 bit segment, 12 bit offset</li><li>Segment goes through process segment table (has length and base), offset then added</li></ul></li></ul></li></ul></li></ul><h1 id="virtual-memory">Virtual Memory</h1><ul><li>Create your memory on demand<ul><li>Onreads, load memory from disk</li><li>when unused, write to disk</li></ul></li><li>Runtime address translation (paging/segmentation) enables noncontiguous memory layouts<ul><li>Programs can no longer directly access memory</li><li>A program can run successfully without loading the whole program into memory at once</li></ul></li></ul><h2 id="how-it-works">How it works</h2><p>At any given time, we need to know:</p><ul><li>Next instruction to execute</li><li>Next data to be accessed</li></ul><p>When a program is executing, run the program until it tries to read or execute something not in ram (this is called a <strong>page fault</strong>). Then, block the process, read in the data, and resume the process. The <strong>residence set</strong> is the part of the program that is in memory.</p><h3 id="performance">Performance</h3><ul><li>lazy loading is a win</li><li>but disk loads in batches is faster</li></ul><h3 id="functionality">Functionality</h3><ul><li>Can juggle more processes at once</li><li>Process can extend a system's RAM size</li></ul><h2 id="replacement">Replacement</h2><ul><li><strong>Thrashing</strong>: Constantly throwing out and reloading memory</li><li><strong>Principle of locality</strong>: stuff you need in the future is close to the stuf you needed in the past</li></ul><h2 id="support">Support</h2><ul><li>Hardware must support paging and segmentation</li><li>OS must support putting pages on desk and reloading them from disk</li><li>Now, virtual addresses have a page number and an offset</li><li>The page table has entries with:<ul><li><strong>Present</strong> flag (is it currently loaded?)</li><li><strong>Modified</strong> flag (has the page been modified since it has been loaded from disk)</li><li>other control bits</li><li>frame number</li></ul></li><li>You can put the page table in memory so it grows, but then you can get two page faults per memory request sometimes</li></ul><h2 id="inverted-page-tables">Inverted Page Tables</h2><ul><li>Inverted means index on frame number, not virtual address</li><li>inverted tables grow with the size of physical memory</li><li>each virtual memory reference can cause two physical memory accesses<ul><li>one to fetch page table entry</li><li>one to fetch data</li></ul></li><li>When a system is too slow, add caches with a <strong>Translation Lookaside Buffer</strong><ul><li>For normal operations, being in the TLB implies that the block is in main memory</li><li>the only time it might not be is in the function that moves memory from one spot to another</li></ul></li><li>smaller page size<ul><li>less amount of internal fragmentation (less memory wasted in last page)</li><li>more pages required per process</li><li>more pages per process means larger page tables</li><li>larger page tables means large portion of page tables in virtual memory</li><li>more tlb entries and therefore more tlb misses</li></ul></li><li>larger page size<ul><li>secondary memory is designed to efficiently transfer large blocks of data so a large page size is better</li><li>after a certain point, larger pages correlates with lower page fault rate</li></ul></li></ul><h3 id="segmentation">Segmentation</h3><p>allows programmer to view memory as consisting of multiple address spaces or segments</p><ul><li>advantages<ul><li>simplifies handling of growing data structures (put whole structure into one segment)</li><li>allows programs to be altered and recompiled independently</li><li>sharing data amongst processes by sharing a segment</li><li>protect segments to have memory protection</li></ul></li><li>segment tables<ul><li>starting address corresponding segment in main memory</li><li>each entry contains length of segment</li><li>bit is needed to determine if the segment is already in main memory</li><li>another bit needed to determine if the segment has been modified since being loaded</li></ul></li><li>paging transparent to programmer, segmentation is visible</li><li>elements<ul><li>1 process</li><li>1 segment table per process</li><li>1 page table per segment</li></ul></li></ul>
</body>
</html>
