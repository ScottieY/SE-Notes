<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/SE-Notes/style.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<h1 id="graph-algorithms">Graph Algorithms</h1><p>In general, we call the number of vertices <span class="math inline">\(n\)</span> and the number of edges <span class="math inline">\(m\)</span>. Edges <span class="math inline">\(E\)</span> consist of sets of two vertices <span class="math inline">\(\{u,w\}, u \ne w\)</span>. The number of edges <span class="math inline">\(m \le \binom{n}{2}\)</span>. A graph can be defined as vertices and edges, <span class="math inline">\(G=(V,E)\)</span>.</p><p>A <strong>Directed graph</strong> or <strong>digraph</strong> has edges (called <strong>arcs</strong> in this case) as an ordered pair <span class="math inline">\((u,w)\)</span> instead of a set, with the arrow going from the tail <span class="math inline">\(u\)</span> to the head <span class="math inline">\(w\)</span>.</p><p><span class="math inline">\(m \le n^2\)</span>.</p><h2 id="adjacency-matrices">Adjacency Matrices</h2><p>The adjacency matrix of a graph <span class="math inline">\(G\)</span> is an <span class="math inline">\(n \times n\)</span> matrix <span class="math inline">\(A=(a_{u,v})\)</span>, which is indexed by <span class="math inline">\(V\)</span>, such that:<br />
<span class="math display">\[a_{u,v} = \begin{cases}
1, &amp;\{u,v\} \in E\\
0, &amp;\text{otherwise}
\end{cases}\]</span></p><p>There are exactly <span class="math inline">\(2m\)</span> etries in <span class="math inline">\(A\)</span> equal to 1.</p><p>If <span class="math inline">\(G\)</span> is a digraph, then:<br />
<span class="math display">\[a_{u,v}=\begin{cases}
1, &amp;(u,v) \in E\\
0, &amp;\text{otherwise}
\end{cases}\]</span></p><p>Storage requirement: <span class="math inline">\(O(n^2)\)</span>.</p><h3 id="properties">Properties</h3><ul><li>Every element in the matrix is either 0 or 1 (are these vertices connected or not)</li><li>In undirected graphs, the matrix is symmetric (<span class="math inline">\(u\)</span> is connected to <span class="math inline">\(v\)</span> and <span class="math inline">\(v\)</span> is connected to <span class="math inline">\(u\)</span> for an edge <span class="math inline">\(uv\)</span>)</li><li>For undirected graphs, diagonal entries are all 0 because a vertex can't be connected to itself by an edge. We allow loops in directed graphs.</li><li>In undirected graphs, the number of 1s int he graph is equal to <span class="math inline">\(2m\)</span>. In directed graphs, the number of 1s is equal to <span class="math inline">\(m\)</span>.</li></ul><h2 id="adjacency-lists">Adjacency Lists</h2><p>The adjacency list of <span class="math inline">\(G\)</span> is <span class="math inline">\(n\)</span> linked lists. For every <span class="math inline">\(u \in V\)</span>, there is a linked list named <span class="math inline">\(Adj[u]\)</span>.</p><p>For every <span class="math inline">\(v \in V\)</span> such that <span class="math inline">\(uv \in E\)</span>, there is a node in <span class="math inline">\(Adj[u]\)</span> labelled <span class="math inline">\(v\)</span> (for both graphs and digraphs).</p><p>In an undirected graph, every edge <span class="math inline">\(uv\)</span> corresponds to a node in two linked lists: for edge <span class="math inline">\(uv, \exists v \in Adj[u]\)</span> and <span class="math inline">\(\exists u \in Adj[v]\)</span>.</p><p>In a directed graph, every edge corresponds to a node in only one adjacency list.</p><h2 id="breadth-first-search">Breadth-first Search</h2><ul><li>Uses a queue</li><li>Looks at elements in one layer of the graph at a time before going to the next layer down (visiting the children of the nodes in the previous layer), starting from vertex <span class="math inline">\(s\)</span></li><li>A vertex is white if undiscovered</li><li>A vertex is grey if it has been discovered, but we are still processing its adjacent vertices</li><li>A vertex is black when all adjacent vertices have been process</li><li>If <span class="math inline">\(G\)</span> is connected, every vertex will eventually be black</li><li>When we explore an edge <span class="math inline">\(\{u,v\}\)</span> starting from <span class="math inline">\(u\)</span>:<ul><li>if <span class="math inline">\(v\)</span> is white, then <span class="math inline">\(uv\)</span> is a <strong>tree edge</strong> and <span class="math inline">\(\pi[v]=u\)</span> is the <strong>predecessor</strong> of <span class="math inline">\(v\)</span> in the bfs tree</li><li>otherwise, <span class="math inline">\(uv\)</span> is a <strong>cross edge</strong></li></ul></li><li>BFS tree consists of all the tree edges</li><li>every vertex <span class="math inline">\(v \ne s\)</span> has a unique predecessor <span class="math inline">\(\pi[v]\)</span> in the BFS tree</li></ul><p><img src="img/bfs.png" /></p><h3 id="shortest-paths">Shortest paths</h3><p><img src="img/bfs-shortestpath.png" /></p><p>The shortest path from <span class="math inline">\(s\)</span> (the source) to some other vertex <span class="math inline">\(v\)</span>:<br />
<span class="math inline">\(v, \pi[v], \pi[\pi[v]], \pi[\pi[\pi[v]]], ...\)</span></p><p>Runtime</p><ul><li>We go once through every adjacency list</li><li>The total number of nodes in all the adjacency lists = <span class="math inline">\(2m\)</span></li><li>Complexity is therefore <span class="math inline">\(\Theta(n+2m) = \Theta(n+m)\)</span></li></ul><h4 id="proof">Proof</h4><h5 id="lemma-1">Lemma 1</h5><p>If <span class="math inline">\(u\)</span> is discovered before <span class="math inline">\(v\)</span>, then <span class="math inline">\(dist[u] \le dist[v]\)</span></p><p>Suppose <span class="math inline">\(u\)</span> is discovered before <span class="math inline">\(v\)</span>, but <span class="math inline">\(dist[u] \gt dist[v]\)</span>. Let <span class="math inline">\(dist[u]=d\)</span>, so <span class="math inline">\(dist[v] \le d-1\)</span>.</p><p>With no loss of generality, choose the first pair of vertices where this happens, so let <span class="math inline">\(\pi[u]=u_1, \pi[v]=v_1\)</span>. Then:<br />
<span class="math display">\[\begin{align*}
d=dist[u]=dist[u_1]+1 &amp;\rightarrow dist[u_1]=d-1\\
d-1 \ge dist[v]=dist[v_1]+1 &amp;\rightarrow dist[v_1]\le d-2 \lt dist[u_1]
\end{align*}\]</span></p><p>So <span class="math inline">\(v_1\)</span> was discovered before <span class="math inline">\(u_1\)</span>. This implies that <span class="math inline">\(Adj[v_1]\)</span> was processed before <span class="math inline">\(Adj[u_1]\)</span>. This only happens if <span class="math inline">\(v\)</span> was discovered before <span class="math inline">\(u\)</span>. This is a contradiction, so therefore if <span class="math inline">\(u\)</span> is discovered before <span class="math inline">\(v\)</span>, then <span class="math inline">\(dist[u] \le dist[v]\)</span>.</p><h5 id="lemma-2">Lemma 2</h5><p>If <span class="math inline">\(\{u,v\}\)</span> is <strong>any edge</strong>, then <span class="math inline">\(|dist[u]-dist[v]| \le 1\)</span></p><p>Suppose <span class="math inline">\(u\)</span> is discovered before <span class="math inline">\(v\)</span> without any loss of generality. Then we are processing <span class="math inline">\(Adj[u]\)</span> when we encounter <span class="math inline">\(v\)</span> in the adjacency list. Then, we have three cases:</p><ol><li><strong><span class="math inline">\(v\)</span> is white.</strong> In this case, <span class="math inline">\(dist[v]=dist[u]-1\)</span>.</li><li><strong><span class="math inline">\(v\)</span> is grey.</strong></li><li><strong><span class="math inline">\(v\)</span> is black.</strong> This can't happen, since it would mean we have already processed the adjacency list for <span class="math inline">\(v\)</span>, and therefore would have encountered <span class="math inline">\(u\)</span> in the adjacency list for <span class="math inline">\(v\)</span>.</li></ol><p>For the second case, let <span class="math inline">\(\pi[v]=v_1\)</span>. This tells us that <span class="math inline">\(dist[v]=dist[v_1]+1\)</span> (1). So <span class="math inline">\(v\)</span> was discovered when <span class="math inline">\(Adj[v_1]\)</span> was being processed. Therefore <span class="math inline">\(v_1\)</span> was discovered before <span class="math inline">\(u\)</span>. This tells us that <span class="math inline">\(dist[v_1] \le dist[u]\)</span> (2). Finally, <span class="math inline">\(u\)</span> was discovered before <span class="math inline">\(v\)</span> from our assumption, so Lemma 1 says that <span class="math inline">\(dist[u] \le dist[v]\)</span>. (3). From (1), (2), and (3), we can say that <span class="math inline">\(|dist[u]-dist[v]| \le 1\)</span>.</p><h5 id="theorem">Theorem</h5><p><span class="math inline">\(dist[v]\)</span> is the length of the <strong>shortest path</strong> from <span class="math inline">\(s\)</span> to <span class="math inline">\(v\)</span></p><p>Let <span class="math inline">\(\delta(v)\)</span> be the lenfth of the shortest path from <span class="math inline">\(s\)</span> to <span class="math inline">\(v\)</span>. We want to prove that <span class="math inline">\(\delta(v) = dist[v]\)</span>. We will prove <span class="math inline">\(\delta(v) \le dist[v]\)</span> and <span class="math inline">\(\delta(v) \ge dist[v]\)</span>.</p><p>Consider the path <span class="math inline">\(v, \pi[v], \pi[\pi[v]], ..., s\)</span>. This is a path from <span class="math inline">\(s\)</span> to <span class="math inline">\(v\)</span> having length <span class="math inline">\(dist[v]\)</span>. Therefore <span class="math inline">\(\delta(v) \le dist[v]\)</span>.</p><p>We prove <span class="math inline">\(\delta(v) \ge dist[v]\)</span> by induction in <span class="math inline">\(\delta(v)\)</span>.</p><p>Base case: <span class="math inline">\(\delta(v) = 0 \rightarrow s=v\)</span>. We know <span class="math inline">\(dist[s]=0\)</span>, so <span class="math inline">\(dist[v]=\delta(v)\)</span>.</p><p>Assumption: Suppose the inequality is true for <span class="math inline">\(\delta(v) \le d-1\)</span>.</p><p>Consider <span class="math inline">\(v\)</span> such that <span class="math inline">\(\delta(v)=d\)</span>. Let <span class="math inline">\(S, v_1, v_2, ..., v_{d-1}, v_d = v\)</span> be the shortest path from <span class="math inline">\(s\)</span> to <span class="math inline">\(v\)</span> (length is <span class="math inline">\(d\)</span>). The section from <span class="math inline">\(s\)</span> to <span class="math inline">\(v_{d-1}\)</span> is a shortest path. By induction, <span class="math inline">\(d-1=\delta(v_{d-1})=dist[v_{d-1}]\)</span>.</p><h3 id="bipartite-graphs">Bipartite graphs</h3><p>A graph is <strong>bipartite</strong> if the vertex set can be partitioned as <span class="math inline">\(V=X \cup Y\)</span> such that all the edges have one end point in <span class="math inline">\(X\)</span> and one in <span class="math inline">\(Y\)</span>. This is the case if and only if there is not an odd cycle in the graph.</p><p>We can use BFS to test if a graph is bipartite.</p><ul><li>If we enounter an edge <span class="math inline">\(\{u,v\}\)</span> with <span class="math inline">\(dist[u]=dist[v]\)</span>, then <span class="math inline">\(G\)</span> os not bipartite, whereas</li><li>if no such edge is found, then define <span class="math inline">\(X = \{u : dist[u] \text{ is even}\}\)</span> and <span class="math inline">\(Y = \{u : dist[u] \text{ is odd}\}\)</span>, and <span class="math inline">\(X,Y\)</span> is the bipartition.</li></ul><p>Suppose <span class="math inline">\(G\)</span> is not bipartite (and assume it is connected). Let <span class="math inline">\(s\)</span> be any vertex.<br />
Define <span class="math inline">\(X=\{v : dist[v] \text{ is even}\}, Y=\{v: dist[v] \text{ is odd}\)</span>.<br />
Since <span class="math inline">\(G\)</span> is not bipartite, there is an edge <span class="math inline">\(uv\)</span> where <span class="math inline">\(u,v \in X\)</span> or <span class="math inline">\(u,v \in Y\)</span>. There is an edge <span class="math inline">\(uv\)</span> where <span class="math inline">\(dist[u]\)</span> and <span class="math inline">\(dist[v]\)</span> are both even or both odd. Since <span class="math inline">\(|dist[u]-dist[v]| \le 1\)</span>, we have <span class="math inline">\(dist[u]=dist[v]\)</span>. How do we find an odd cycle?</p><p>Given a connected graph, we can use BFS to either:</p><ol><li>Find a bipartition <span class="math inline">\(X,Y\)</span> (<span class="math inline">\(G\)</span> is bipartite), or</li><li>Find an odd length cycle (<span class="math inline">\(G\)</span> is not bipartite)</li></ol><p>Run BFS. IF we ever encounter <span class="math inline">\(v \in Adj[u]\)</span> where <span class="math inline">\(dist[u] = dist[v]\)</span>, then we can construct an odd cycle. If this doesn't happen, then <span class="math inline">\(X,Y\)</span> will be a bipartition.</p><h2 id="depth-first-search">Depth-first Search</h2><ul><li>Uses a stack or recursion</li><li>Looks at most deeply nested children first, then parents</li></ul><p><img src="img/dfs.png" /><br />
<img src="img/dfsvisit.png" /></p>
</body>
</html>
